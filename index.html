<!DOCTYPE html>
<html lang="en" id="whole">
  <head>
    <!-- do not change or delete this file, it is for making the password page -->
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      content="width=device-width"
      initial-scale="1.0"
      maximum-scale="1.0"
      user-scalable="0"
      name="viewport"
    />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" href="img/icons8-inspection-40.png" type="image/x-icon" />
    <title>Bid Maker</title>
    <!-- <link rel="stylesheet" href="styles.css" /> -->
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: Arial, Helvetica, sans-serif;
        font-size: 14px;
      }

      body {
        position: relative;
      }

      .modal {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.6);
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        height: 100%;
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.2s ease, visiblity 0.2s ease;
      }

      .modal_visible {
        display: flex;
        position: absolute;
        background-color: rgba(0, 0, 0, 0.6);
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        height: 100%;
        justify-content: center;
        align-items: center;
        visibility: visible;
        opacity: 1;
        transition: opacity 0.2s ease, visiblity 0.2s ease;
      }

      .modal__container {
        padding: 20px;
        border: 1px solid black;
        background-color: #414141;
        color: white;
        max-width: 50%;
      }

      .container__input {
        width: 100%;
        margin-top: 20px;
        color: black;
      }

      .container__buttons {
        display: flex;
        justify-content: flex-end;
        gap: 20px;
        margin-top: 20px;
      }

      .container__title {
        font-size: 1.25rem;
      }

      .button {
        padding: 5px 15px;
        border: none;
        cursor: pointer;
      }

      .button_confirm {
        background-color: #26e600;
      }

      .button_cancel {
        background-color: rgb(240, 90, 90);
      }

      .cancel-button,
      .set-button {
        border: none;
        border-radius: 5px;
        padding: 10px;
        font-size: 14px;
        background-color: transparent;
        font-weight: bold;
      }

      .cancel-button:hover,
      .set-button:hover {
        cursor: pointer;
        background-color: rgba(0, 0, 0, 0.6);
      }

      .selector-button {
        padding: 10px;
        border: none;
        border-bottom: 2px solid black;
        border-radius: 5px;
      }

      .selector-button:last-of-type {
        border-bottom: 2px solid rgb(126, 126, 126);
      }

      .selector-button:hover {
        cursor: pointer;
      }

      .color-preview {
        height: 25px;
        width: 25px;
        background-color: black;
        border-radius: 50%;
        border: 2px solid black;
        transition: background-color 0.5s;
        transition: border 0.5s;
      }

      .red {
        background-color: red;
      }

      .cyan {
        background-color: cyan;
      }

      .blue {
        background-color: blue;
      }

      .green {
        background-color: #2efc05;
      }

      .pink {
        background-color: magenta;
      }

      .yellow {
        background-color: yellow;
      }

      .black {
        background-color: #000;
        color: #fff;
      }

      .module {
        position: absolute;
        display: none;
        place-items: center;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100vw;
        background-color: rgba(1, 1, 1, 0.8);
        z-index: 9999;
      }

      .visible {
        display: grid;
      }

      #canvas {
        /* background-color: transparent; */
        background-size: cover;
        /* background-color: aquamarine; */
        border: 1px solid #000000;
        border-top: none;
        border-left: none;
      }

      .header-logo {
        width: 200px;
        margin-left: 20px;
        margin-bottom: 15px;
        position: relative;
        z-index: -1;
      }

      .header-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        height: 140px;
      }

      .date-container {
        align-self: flex-end;
        padding: 20px;
      }

      .customer-details-header {
        color: rgb(255, 255, 255);
        background-color: black;
        margin: 0;
        padding: 10px;
        letter-spacing: 3px;
        border: 2px solid black;
      }

      .customer-details-body {
        display: grid;
        grid-template-columns: 1fr 7fr 1fr 7fr;
        margin-bottom: 0;
        /* border: 1px solid green; */
      }

      .customer-details-body2 {
        display: grid;
        grid-template-columns: 1fr 7fr;
        /* border: 1px solid red; */
        margin-top: 0px !important;
      }

      #email {
        flex-grow: 1;
        text-align: left;
      }

      .label {
        width: 100px;
      }

      select {
        text-align: right;
        border: none;
      }

      .form-wrapper {
        margin: 0 auto;
        max-width: 820px;
      }

      .section2 {
        display: flex;
        max-width: 820px;
      }

      .canvas-side,
      .material-side {
        display: inline-block;
      }

      .material-side {
        border-bottom: 2px solid black;
        border-right: 2px solid black;
      }

      .canvas-side {
        border-left: 2px solid black;
        border-bottom: 2px solid black;
      }

      .material-side {
        flex-grow: 1;
      }

      .material-details-header,
      .extra-and-pricing-header,
      .job-notes-header {
        text-align: center;
        padding: 5px;
        background-color: black;
        color: white;
        letter-spacing: 3px;
      }

      .job-notes {
        background-color: black;

        display: block;
        letter-spacing: 3px;
        margin-top: 5px;
      }

      #job-notes {
        width: 100%;
        padding: 5px;
        font-size: 11px;
        resize: none;
        border-right: none;
        border-bottom: none;
        border-left: 1px solid black;
      }

      .material-details-body,
      .extra-and-pricing-body {
        display: grid;
        grid-template-columns: 1fr 2fr;
      }

      form {
        padding: 10px;
        width: 100%;
      }

      label {
        background-color: rgb(65, 65, 65);
        color: rgb(255, 255, 255);

        padding: 5px 10px;
        font-weight: bold;
        letter-spacing: 1px;
        border: 1px solid rgba(0, 0, 0, 0.6);
        min-height: 15px;
      }

      .material-details-body input,
      .extra-and-pricing-body input {
        text-align: right;
        width: 100%;
        font-size: 10px;
        padding: 3px;
      }

      .material-details-body label,
      .extra-and-pricing-body label {
        font-size: 10px;
        font-weight: bolder;
      }

      label,
      input {
        border: none;
        border-bottom: 1px solid black;
        padding: 5px;
        /* min-height: 10px; */
      }

      .tools-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0;
        padding: 0px 5px;
        max-width: 500px;
      }

      .tools-bar button,
      .tools-bar input,
      .tools-bar select {
        border-radius: 5px;
        padding: 5px 10px;
        background-color: silver;
        flex-grow: 1;
        margin: auto 3px;
        max-height: 30px;
        font-size: 12px;
        font-weight: 600;
      }

      .tools-bar select {
        font-weight: 400;
      }

      #clear-button {
        background-color: rgb(241, 112, 112);
      }

      #tool-select {
        text-align: left;
        background-color: silver;
        border: none;
        border-radius: 5px;
        width: 70px;
      }

      #finish-button {
        background: rgb(94, 235, 94);
      }

      #grid-size {
        max-width: 70px;
      }

      @media print {
        body {
          print-color-adjust: exact;
          -webkit-print-color-adjust: exact;
        }
      }

      .legend {
        /* text-align: center; */
        padding: 10px;
        transition: height 1s ease-in-out;
      }

      .legend-pic {
        height: 160px;
      }

      .legend-pic.hidden {
        height: 0px;
      }

      #additions,
      #additions2,
      #additions3,
      #screen {
        resize: none;
        padding: 1px;
        text-align: right;
        overflow: hidden;
        font-size: 10px;
        scroll-behavior: none;
      }

      #additions-label,
      #additions2-label,
      #screen-label {
        display: flex;
        align-items: center;
      }

      #color {
        text-align: center;
        padding: 0;
        height: 25px;
      }
    </style>
  </head>

  <body>
    <div class="modal">
      <div class="modal__container">
        <h2 class="container__title">
          Enter the elbow sequence or the length of the piece. (ex: AABA, 57")
        </h2>
        <input id="textinput" type="text" class="container__input" />
        <div class="container__buttons">
          <button type="button" class="button button_cancel">Cancel</button>
          <button type="button" class="button button_confirm">OK</button>
        </div>
      </div>
    </div>
    <div class="form-wrapper">
      <form>
        <div class="header-container">
          <img class="header-logo" src="./img/peaux-logo.png" alt="logo" />
          <div class="date-container">
            <label for="date">Date:</label>
            <input id="date" class="input form-field" type="date" />
          </div>
        </div>
        <div class="customer-details-container">
          <div class="customer-details-header">
            <h2>CUSTOMER DETAILS</h2>
          </div>
          <div class="customer-details-body">
            <label class="label" for="name">Name:</label>
            <input
              id="name"
              name="name"
              type="text"
              maxlength="100"
              minlength="1"
            />

            <label class="label" for="phone">Phone:</label>
            <input type="text" name="phone" id="phone" />
          </div>
          <div class="customer-details-body2">
            <label class="label" for="address">Address:</label>
            <input type="text" name="address" id="address" />

            <label class="label" for="email">Email:</label>
            <input type="email" name="email" id="email" />
          </div>
        </div>

        <div class="section2">
          <div class="canvas-side">
            <canvas id="canvas"></canvas>
            <div class="tools-bar">
              <select id="tool-select">
                <option value="gutter">Gutter</option>
                <!-- <option value="gutter-w-screen">Gutter w/ Screen</option> -->
                <option value="existing-gutter">Existing Gutter</option>
                <option value="downspout">Downspout</option>
                <option value="drop">Drop to lower</option>
                <option value="valley-shield">Valley Shield</option>
                <option value="free-text">Elbow Seq/Piece Length</option>
                <option value="eraser">Eraser</option>
                <!-- <option value="flashing">Flashing</option>
              <option value="fascia-repair">Fascia Repair/Replace</option> -->
              </select>
              <input
                type="number"
                min="10"
                max="50"
                id="grid-size"
                value="14"
              />
              <!-- <button id="color">Color</button> -->
              <select id="color">
                <option
                  value="black"
                  style="background-color: black; color: white"
                >
                  Black
                </option>
                <option value="red" style="background-color: red; color: white">
                  Red
                </option>
                <option
                  value="cyan"
                  style="background-color: cyan; color: black"
                >
                  Cyan
                </option>
                <option
                  value="blue"
                  style="background-color: blue; color: white"
                >
                  Blue
                </option>
                <option
                  value="green"
                  style="background-color: #2efc05; color: black"
                >
                  Green
                </option>
                <option
                  value="magenta"
                  style="background-color: magenta; color: black"
                >
                  Magenta
                </option>
                <option value="yellow" style="background-color: yellow">
                  Yellow
                </option>
              </select>
              <button type="button" class="undo-button">Undo</button>
              <button type="button" id="clear-button">Clear</button>
              <!-- <button type="button" id="show-legend" onclick="showLegend()">LGND</button> -->
              <button type="button" id="finish-button" onclick="finish()">
                Done
              </button>
            </div>
            <label for="job-notes" class="job-notes">
              JOB DESCRIPTION / NOTES
            </label>
            <textarea
              name="job-description"
              id="job-notes"
              rows="10"
            ></textarea>
          </div>
          <div class="material-side">
            <div class="material-details">
              <div class="material-details-header">
                <h3>MATERIAL</h3>
              </div>
              <div class="material-details-body">
                <label for="coil-color" class="coil-color"
                  >Coil Color/Size:</label
                >
                <input type="text" name="coil-color" id="coil-color" />

                <label for="coil-footage" class="coil-footage"
                  >Coil Footage:</label
                >
                <input
                  type="text"
                  min="0"
                  max="99999"
                  name="coil-footage"
                  id="coil-footage"
                />

                <!-- <label for="size" class="size-label">Coil Size:</label>
              <input type="text" maxlength="100" id="size"> -->

                <label for="downspout-color" class="downspout-color"
                  >DS Color/Size:</label
                >
                <input type="text" name="color" id="downspout-color" />

                <label for="ds-footage" class="ds-footage">DS Footage:</label>
                <input
                  type="text"
                  min="0"
                  max="99999"
                  name="ds-footage"
                  id="ds-footage"
                />

                <label for="splash-guards" class="splashBlocks"
                  >Splash Guards:</label
                >
                <input type="text" name="splash-guards" id="splash-guards" />
                <!-- <label for="downspout-size" class="downspout-size">DS Size:</label>
              <input type="text" maxlength="100" id="downspout=size"> -->
                <!-- hatest -->
                <label for="ism" class="ism">ISM:</label>
                <input type="text" min="0" max="99999" name="ism" id="ism" />

                <label for="osm" class="osm">OSM:</label>
                <input type="text" min="0" max="99999" name="osm" id="osm" />

                <label for="custom-miters" class="custom-miters"
                  >Custom Miters:</label
                >
                <input
                  type="text"
                  min="0"
                  max="99999"
                  name="custom-miters"
                  id="custom-miters"
                />

                <label for="end-caps">End Caps:</label>
                <input
                  min="0"
                  max="99999"
                  type="text"
                  name="end-caps"
                  id="end-caps"
                />

                <label for="a-elbows">A's:</label>
                <input
                  min="0"
                  max="99999"
                  type="text"
                  name="a-elbows"
                  id="a-elbows"
                />

                <label for="b-elbows">B's:</label>
                <input
                  min="0"
                  max="99999"
                  type="text"
                  name="b-elbows"
                  id="b-elbows"
                />

                <label for="offsets">Offsets:</label>
                <input
                  min="0"
                  max="99999"
                  type="text"
                  name="offsets"
                  id="offsets"
                />

                <label for="splash-blocks">Splash Blocks:</label>
                <input
                  min="0"
                  max="99999"
                  type="text"
                  name="splash-blocks"
                  id="splash-blocks"
                />
              </div>
            </div>
            <div class="pricing-container">
              <div class="extra-and-pricing-header">
                <h3>EXTRA</h3>
              </div>
              <div class="extra-and-pricing-body">
                <label for="drip-edge">Drip Edge:</label>
                <input
                  min="0"
                  max="99999"
                  type="text"
                  name="drip-edge"
                  id="drip-edge"
                />

                <label for="screen" id="screen-label">Screen:</label>
                <!-- <input type="text" min="0" max="100" name="screen" id="screen"> -->
                <textarea id="screen" rows="6"></textarea>

                <!-- <label for="screen-footage">Screen Footage:</label>
              <input min="0" max="99999" type="text" name="screen-footage" id="screen-footage"> -->

                <label for="other">Gutter and Ds:</label>
                <input type="text" name="other" id="other" placeholder="$" />

                <label for="additions3" id="additions3-label">Additions:</label>
                <!-- <input type="text" name="additions" id="additons" placeholder="$"> -->
                <textarea rows="3" id="additions3" placeholder="$"></textarea>

                <label for="additions" id="additions2-label">Additions:</label>
                <!-- <input type="text" name="additions" id="additons" placeholder="$"> -->
                <textarea rows="3" id="additions" placeholder="$"></textarea>

                <label for="additions2" id="additions-label">Additions:</label>
                <!-- <input type="text" name="additions" id="additons2" placeholder="$"> -->
                <textarea rows="3" id="additions2" placeholder="$"></textarea>

                <label for="total">Grand Total:</label>
                <input type="text" name="total" id="total" placeholder="$" />
              </div>
            </div>
          </div>
        </div>
      </form>
    </div>

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"
      integrity="sha512-GsLlZN/3F2ErC5ifS5QtgpiJtWd43JWSuIgh7mbzZ8zBps+dvLusV+eNQATqgA/HdeKFVgA5v3S/cIrLF7QnIg=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <!-- <script src="scripts.js"></script> -->
    <script>
      // const canvas = document.getElementById("canvas");
      // const ctx = canvas.getContext("2d");
      // const undoBtn = document.querySelector(".undo-button");
      // const clearButton = document.querySelector("#clear-button");
      // const colorPicker = document.querySelector("#color");
      // const gridSizeInput = document.querySelector("#grid-size");
      // const tool = document.querySelector("#tool-select");
      // const textInputEl = document.querySelector(".container__input");
      // const cancelBtn = document.querySelector(".button_cancel");
      // const confirmBtn = document.querySelector(".button_confirm");
      // const modal = document.querySelector(".modal");

      // let isDrawing = false;
      // let startX, startY, currentX, currentY;
      // let paths = [];
      // let index = -1;
      // let rubberLinePath = null;

      // // Initialize Canvas
      // function startup() {
      //   canvas.width = 500;
      //   canvas.height = 500;
      //   drawGrid();
      //   updateUndoButton();
      // }

      // // Draw the grid on the canvas
      // function drawGrid() {
      //   const gridSize = parseInt(gridSizeInput.value);
      //   ctx.clearRect(0, 0, canvas.width, canvas.height);
      //   ctx.strokeStyle = "lightgray";
      //   for (let x = 0; x < canvas.width; x += gridSize) {
      //     ctx.beginPath();
      //     ctx.moveTo(x, 0);
      //     ctx.lineTo(x, canvas.height);
      //     ctx.stroke();
      //   }
      //   for (let y = 0; y < canvas.height; y += gridSize) {
      //     ctx.beginPath();
      //     ctx.moveTo(0, y);
      //     ctx.lineTo(canvas.width, y);
      //     ctx.stroke();
      //   }
      // }

      // // Snap coordinates to the nearest grid point
      // function snapToGrid(value) {
      //   const gridSize = parseInt(gridSizeInput.value);
      //   return Math.round(value / gridSize) * gridSize;
      // }

      // // Get coordinates from event (supports both mouse and touch)
      // function getCoordinates(event) {
      //   const rect = canvas.getBoundingClientRect();
      //   const x = event.touches ? event.touches[0].clientX : event.clientX;
      //   const y = event.touches ? event.touches[0].clientY : event.clientY;
      //   return {
      //     x: snapToGrid(x - rect.left),
      //     y: snapToGrid(y - rect.top),
      //   };
      // }

      // // Update the color based on user selection
      // function updateColor() {
      //   ctx.strokeStyle = colorPicker.value;
      //   ctx.fillStyle = colorPicker.value;
      // }

      // function addToUndoStack() {
      //   paths.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
      //   index++;
      //   updateUndoButton();
      // }

      // // Start drawing
      // function startDrawing(event) {
      //   isDrawing = true;
      //   const { x, y } = getCoordinates(event);
      //   startX = x;
      //   startY = y;
      //   updateColor();
      //   if (tool.value === "gutter") {
      //     ctx.setLineDash([]);
      //   } else if (tool.value === "existing-gutter") {
      //     ctx.setLineDash([2, 2]);
      //   } else if (tool.value === "downspout" || tool.value === "drop") {
      //     ctx.setLineDash([]);
      //   }
      // }

      // // Draw a rubber line
      // function drawRubberLine(event) {
      //   if (
      //     !isDrawing ||
      //     tool.value === "downspout" ||
      //     tool.value === "drop" ||
      //     tool.value === "valley-shield" ||
      //     tool.value === "free-text"
      //   )
      //     return;
      //   const { x, y } = getCoordinates(event);
      //   currentX = x;
      //   currentY = y;

      //   if (rubberLinePath) {
      //     ctx.putImageData(rubberLinePath, 0, 0); // Clear temporary line
      //   } else {
      //     rubberLinePath = ctx.getImageData(0, 0, canvas.width, canvas.height);
      //   }

      //   ctx.beginPath();
      //   ctx.moveTo(startX, startY);
      //   ctx.lineTo(currentX, currentY);
      //   ctx.lineWidth = 2;
      //   ctx.stroke();
      // }

      // // Finalize the line on pointer up
      // function stopDrawing() {
      //   if (isDrawing) {
      //     isDrawing = false;
      //     rubberLinePath = null; // Clear rubber band

      //     if (tool.value === "downspout") {
      //       ctx.beginPath();
      //       ctx.moveTo(startX, startY);
      //       ctx.lineTo(
      //         startX + gridSizeInput.value / 2.75,
      //         startY + gridSizeInput.value / 2.75
      //       );
      //       ctx.moveTo(startX, startY);
      //       ctx.lineTo(
      //         startX - gridSizeInput.value / 2.75,
      //         startY + gridSizeInput.value / 2.75
      //       );
      //       ctx.moveTo(startX, startY);
      //       ctx.lineTo(
      //         startX - gridSizeInput.value / 2.75,
      //         startY - gridSizeInput.value / 2.75
      //       );
      //       ctx.moveTo(startX, startY);
      //       ctx.lineTo(
      //         startX + gridSizeInput.value / 2.75,
      //         startY - gridSizeInput.value / 2.75
      //       );
      //       ctx.stroke();
      //       addToUndoStack();
      //     } else if (tool.value === "drop") {
      //       ctx.beginPath();
      //       ctx.arc(startX, startY, gridSizeInput.value / 4, 0, 2 * Math.PI);
      //       ctx.stroke();
      //       addToUndoStack();
      //     } else if (tool.value === "valley-shield") {
      //       ctx.beginPath();
      //       ctx.arc(startX, startY, gridSizeInput.value / 4, 0, 2 * Math.PI);
      //       ctx.fill();
      //       addToUndoStack();
      //     } else if (tool.value === "free-text") {
      //       modal.classList.add("modal_visible");
      //       // let userInput = prompt(
      //       //   'Type in the elbow sequence or the length of the piece. (ex: AABA, 57")'
      //       // );
      //     } else {
      //       ctx.beginPath();
      //       ctx.moveTo(startX, startY);
      //       ctx.lineTo(currentX, currentY);
      //       ctx.lineWidth = 2;
      //       ctx.stroke();

      //       // Save the path state
      //       addToUndoStack();
      //     }
      //   }
      // }

      // // Undo the last action
      // undoBtn.addEventListener("click", () => {
      //   undo();
      // });

      // function undo() {
      //   if (index <= 0) {
      //     clearCanvas();
      //   } else {
      //     index--;
      //     paths.pop();
      //     ctx.putImageData(
      //       paths[index] || ctx.getImageData(0, 0, canvas.width, canvas.height),
      //       0,
      //       0
      //     );
      //     updateUndoButton();
      //   }
      // }

      // // Clear the canvas
      // function clearCanvas() {
      //   ctx.clearRect(0, 0, canvas.width, canvas.height);
      //   drawGrid();
      //   paths = [];
      //   index = -1;
      //   updateUndoButton();
      // }

      // clearButton.addEventListener("click", clearCanvas);

      // // Update the undo button
      // function updateUndoButton() {
      //   undoBtn.innerText = paths.length > 0 ? "Undo" : "Update Grid";
      //   undoBtn.style.backgroundColor = paths.length > 0 ? "silver" : "#d9f170";
      // }

      // function placeText(x, y) {
      //   const userInput = textInputEl.value;
      //   ctx.font = "1000 12px Arial";
      //   ctx.fillStyle = "black";
      //   ctx.textAlign = "center";
      //   if (!userInput) {
      //     return;
      //   } else {
      //     ctx.fillText(`${userInput}`, x, y);
      //     addToUndoStack();
      //   }
      //   textInputEl.value = "";
      //   modal.classList.remove("modal_visible");
      // }

      // // Add event listeners
      // canvas.addEventListener("pointerdown", startDrawing);
      // canvas.addEventListener("pointermove", drawRubberLine);
      // canvas.addEventListener("pointerup", stopDrawing);
      // canvas.addEventListener("pointerout", stopDrawing);

      // cancelBtn.addEventListener("click", (e) => {
      //   modal.classList.remove("modal_visible");
      //   textInputEl.value = "";
      // });

      // confirmBtn.addEventListener("click", (e) => {
      //   placeText(startX, startY);
      // });

      // // Add touch events for mobile and tablets
      // canvas.addEventListener("touchstart", (event) => {
      //   event.preventDefault();
      //   startDrawing(event);
      // });
      // canvas.addEventListener("touchmove", (event) => {
      //   event.preventDefault();
      //   drawRubberLine(event);
      // });
      // canvas.addEventListener("touchend", (event) => {
      //   event.preventDefault();
      //   stopDrawing();
      // });
      // canvas.addEventListener("touchcancel", stopDrawing);

      // // Initialize on DOMContentLoaded
      // document.addEventListener("DOMContentLoaded", startup);
      // document.addEventListener("keydown", (e) => {
      //   if (e.key === "Escape") {
      //     undo();
      //   }
      // });

      function finish() {
        window.onbeforeprint = (event) => {
          toolsBar = document.querySelector(".tools-bar");
          toolsBar.style.display = "none";
          legendPic = document.querySelector(".legend-pic");
        };
        window.print();
      }

      window.onafterprint = (event) => {
        toolsBar = document.querySelector(".tools-bar");
        toolsBar.style.display = "flex";
      };

      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const undoBtn = document.querySelector(".undo-button");
      const clearButton = document.querySelector("#clear-button");
      const colorPicker = document.querySelector("#color");
      const gridSizeInput = document.querySelector("#grid-size");
      const tool = document.querySelector("#tool-select");
      const textInputEl = document.querySelector(".container__input");
      const cancelBtn = document.querySelector(".button_cancel");
      const confirmBtn = document.querySelector(".button_confirm");
      const modal = document.querySelector(".modal");

      let isDrawing = false;
      let startX, startY, currentX, currentY;
      let lines = []; // Store start and end coordinates for lines
      let index = -1;
      let rubberLinePath = null;
      let history = []; // History to store previous states of the canvas

      // Initialize Canvas
      function startup() {
        canvas.width = 500;
        canvas.height = 500;
        drawGrid();
        updateUndoButton();
      }

      // Draw the grid on the canvas
      function drawGrid() {
        ctx.setLineDash([]);
        const gridSize = parseInt(gridSizeInput.value);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "lightgray";
        for (let x = 0; x < canvas.width; x += gridSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        for (let y = 0; y < canvas.height; y += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
      }

      // Snap coordinates to the nearest grid point
      function snapToGrid(value) {
        const gridSize = parseInt(gridSizeInput.value);
        return Math.round(value / gridSize) * gridSize;
      }

      // Get coordinates from event (supports both mouse and touch)
      function getCoordinates(event) {
        const rect = canvas.getBoundingClientRect();
        const x = event.touches ? event.touches[0].clientX : event.clientX;
        const y = event.touches ? event.touches[0].clientY : event.clientY;
        return {
          x: snapToGrid(x - rect.left),
          y: snapToGrid(y - rect.top),
        };
      }

      // Update the color based on user selection
      function updateColor() {
        ctx.strokeStyle = colorPicker.value;
        ctx.fillStyle = colorPicker.value;
      }

      // Start drawing
      function startDrawing(event) {
        isDrawing = true;
        const { x, y } = getCoordinates(event);
        startX = x;
        startY = y;
        ctx.lineWidth = 2;
        updateColor();

        if (tool.value === "gutter") {
          ctx.setLineDash([]);
        } else if (tool.value === "existing-gutter") {
          ctx.setLineDash([2, 2]);
        } else if (tool.value === "downspout" || tool.value === "drop") {
          ctx.setLineDash([]);
        }

        if (tool.value === "eraser") {
          // Additional eraser logic if needed
          return;
        }
      }

      // Draw a rubber line (for both drawing and erasing)
      function drawRubberLine(event) {
        if (
          !isDrawing ||
          tool.value === "downspout" ||
          tool.value === "free-text" ||
          tool.value === "drop" ||
          tool.value === "valley-shield" ||
          tool.value === "eraser"
        )
          return;

        const { x, y } = getCoordinates(event);
        currentX = x;
        currentY = y;

        if (rubberLinePath) {
          ctx.putImageData(rubberLinePath, 0, 0); // Clear temporary line
        } else {
          rubberLinePath = ctx.getImageData(0, 0, canvas.width, canvas.height);
        }

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(currentX, currentY);
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // Finalize the line on pointer up
      function stopDrawing(event) {
        if (isDrawing) {
          isDrawing = false;
          rubberLinePath = null; // Clear rubber band

          if (tool.value === "downspout") {
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(
              startX + gridSizeInput.value / 2.75,
              startY + gridSizeInput.value / 2.75
            );
            ctx.moveTo(startX, startY);
            ctx.lineTo(
              startX - gridSizeInput.value / 2.75,
              startY + gridSizeInput.value / 2.75
            );
            ctx.moveTo(startX, startY);
            ctx.lineTo(
              startX - gridSizeInput.value / 2.75,
              startY - gridSizeInput.value / 2.75
            );
            ctx.moveTo(startX, startY);
            ctx.lineTo(
              startX + gridSizeInput.value / 2.75,
              startY - gridSizeInput.value / 2.75
            );
            ctx.stroke();
            // Add line coordinates instead of ImageData
            lines.push({
              startX,
              startY,
              endX: startX,
              endY: startY,
              tool: tool.value,
              color: colorPicker.value,
            });
            updateUndoButton();
          } else if (tool.value === "drop") {
            ctx.beginPath();
            ctx.arc(startX, startY, gridSizeInput.value / 4, 0, 2 * Math.PI);
            ctx.stroke();
            // Add line coordinates instead of ImageData
            lines.push({
              startX,
              startY,
              endX: startX,
              endY: startY,
              tool: tool.value,
              color: colorPicker.value,
            });
            updateUndoButton();
          } else if (tool.value === "valley-shield") {
            ctx.beginPath();
            ctx.arc(startX, startY, gridSizeInput.value / 4, 0, 2 * Math.PI);
            ctx.fill();
            // Add line coordinates instead of ImageData
            lines.push({
              startX,
              startY,
              endX: startX,
              endY: startY,
              tool: tool.value,
              color: colorPicker.value,
            });
            updateUndoButton();
          } else if (tool.value === "free-text") {
            modal.classList.add("modal_visible");
          } else if (tool.value === "eraser") {
            console.log(startX, startY);
            eraseNearestLine(); // Call the erase function to remove entire lines
          } else {
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(currentX, currentY);
            ctx.lineWidth = 2;
            ctx.stroke();
            // Add line coordinates instead of ImageData
            lines.push({
              startX,
              startY,
              endX: currentX,
              endY: currentY,
              tool: tool.value,
              color: colorPicker.value,
            });
            updateUndoButton();
          }
          if (tool.value !== "free-text") {
            saveState();
          }
        }
      }

      function placeText(x, y) {
        const userInput = textInputEl.value;
        ctx.font = "1000 12px Arial";
        ctx.fillStyle = "black";
        ctx.textAlign = "center";
        if (!userInput) {
          return;
        } else {
          ctx.fillText(`${userInput}`, x, y);
          // addToUndoStack();
          lines.push({
            startX,
            startY,
            endX: startX,
            endY: startY,
            tool: tool.value,
            content: userInput,
            color: colorPicker.value,
          });
          saveState();
        }
        textInputEl.value = "";
        modal.classList.remove("modal_visible");
      }

      function eraseNearestLine() {
        const tolerance = 10; // Tolerance in pixels for erasing (you can adjust this)

        // Loop through the stored lines and check if they intersect with the eraser area
        for (let i = lines.length - 1; i >= 0; i--) {
          let line = lines[i];

          // Check if the line is within the eraser's tolerance
          if (
            isLineCloseToCursor(
              line.startX,
              line.startY,
              line.endX,
              line.endY,
              startX,
              startY,
              tolerance
            )
          ) {
            lines.splice(i, 1); // Remove the line from lines
            redrawCanvas(); // Redraw canvas with updated lines
            break;
          }
          if (
            line.tool === "downspout" ||
            line.tool === "drop" ||
            line.tool === "valley-shield" ||
            line.tool === "free-text"
          ) {
            if (
              distanceBetweenPoints(line.startX, line.startY, startX, startY) <
              10
            ) {
              lines.splice(i, 1); // Remove the line from lines
              redrawCanvas(); // Redraw canvas with updated lines
              break;
            }
          }
        }
        updateUndoButton(); // Keep track of the undo stack after erasing a line
      }

      // Function to check if a line intersects with the eraser's area
      // function lineIntersects(x1, y1, x2, y2, line, tolerance) {
      //   const dx = x2 - x1;
      //   const dy = y2 - y1;
      //   const dist =
      //     Math.abs(dy * line.startX - dx * line.startY + x2 * y1 - y2 * x1) /
      //     Math.sqrt(dx * dx + dy * dy);
      //   return dist <= tolerance;
      // }

      // Function to calculate the distance from a point to a line
      // Function to check if a line intersects with the eraser's area
      function isLineCloseToCursor(x1, y1, x2, y2, mouseX, mouseY, radius) {
        // Calculate the perpendicular distance from the mouse to the line
        const distance = pointToLineDistance(x1, y1, x2, y2, mouseX, mouseY);

        // Check if the distance is within the given radius
        return distance <= radius;
      }

      // Function to calculate the perpendicular distance from a point to a line
      function pointToLineDistance(x1, y1, x2, y2, px, py) {
        // Calculate the distance using the point-to-line distance formula
        const numerator = Math.abs(
          (y2 - y1) * px - (x2 - x1) * py + x2 * y1 - y2 * x1
        );
        const denominator = Math.sqrt(
          Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2)
        );
        return numerator / denominator;
      }

      function distanceBetweenPoints(x1, y1, x2, y2) {
        const dx = x2 - x1; // Difference in x coordinates
        const dy = y2 - y1; // Difference in y coordinates

        // Apply the distance formula
        return Math.sqrt(dx * dx + dy * dy);
      }

      // Redraw the entire canvas based on stored lines
      function redrawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.setLineDash([]);
        drawGrid();
        updateColor();
        lines.forEach((line) => {
          console.log(line.color);
          ctx.strokeStyle = line.color;
          ctx.fillStyle = line.color;
          if (line.tool === "downspout") {
            ctx.beginPath();
            ctx.moveTo(line.startX, line.startY);
            ctx.lineTo(
              line.startX + gridSizeInput.value / 2.75,
              line.startY + gridSizeInput.value / 2.75
            );
            ctx.moveTo(line.startX, line.startY);
            ctx.lineTo(
              line.startX - gridSizeInput.value / 2.75,
              line.startY + gridSizeInput.value / 2.75
            );
            ctx.moveTo(line.startX, line.startY);
            ctx.lineTo(
              line.startX - gridSizeInput.value / 2.75,
              line.startY - gridSizeInput.value / 2.75
            );
            ctx.moveTo(line.startX, line.startY);
            ctx.lineTo(
              line.startX + gridSizeInput.value / 2.75,
              line.startY - gridSizeInput.value / 2.75
            );
            ctx.setLineDash([]);
            ctx.stroke();
          } else if (line.tool === "drop") {
            ctx.beginPath();
            ctx.arc(
              line.startX,
              line.startY,
              gridSizeInput.value / 4,
              0,
              2 * Math.PI
            );
            ctx.setLineDash([]);
            ctx.stroke();
          } else if (line.tool === "valley-shield") {
            ctx.beginPath();
            ctx.arc(
              line.startX,
              line.startY,
              gridSizeInput.value / 4,
              0,
              2 * Math.PI
            );
            ctx.setLineDash([]);
            ctx.fill();
          } else if (line.tool === "existing-gutter") {
            ctx.beginPath();
            ctx.moveTo(line.startX, line.startY);
            ctx.lineTo(line.endX, line.endY);
            ctx.lineWidth = 2;
            ctx.setLineDash([2, 2]);
            ctx.stroke();
          } else if (line.tool === "free-text") {
            ctx.font = "1000 12px Arial";
            ctx.fillStyle = "black";
            ctx.textAlign = "center";
            ctx.fillText(line.content, line.startX, line.startY);
          } else {
            ctx.beginPath();
            ctx.moveTo(line.startX, line.startY);
            ctx.lineTo(line.endX, line.endY);
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.stroke();
          }
        });
      }

      // Undo the last action
      undoBtn.addEventListener("click", () => {
        undo();
      });

      function undo() {
        // debugger;
        if (history.length > 0) {
          // Pop the last saved state and restore the lines array
          history.pop();
          lines = history[history.length - 1];
          redrawCanvas(); // Redraw canvas with the previous state
          updateUndoButton(); // Update undo button state
        } else {
          clearCanvas(); // If no history, clear the canvas
        }
        updateUndoButton();
        console.log(lines, history);
      }

      function saveState() {
        history.push([...lines]); // Copy the current lines array to preserve the state
      }

      // Clear the canvas
      function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        lines = []; // Clear current lines
        history = []; // Clear history
        index = -1; // Reset the index (this is unnecessary)
        updateUndoButton(); // Update the undo button state
      }

      clearButton.addEventListener("click", clearCanvas);

      // Update the undo button
      function updateUndoButton() {
        if (lines && history) {
          undoBtn.innerText =
            lines.length > 0 && history.length > 0 ? "Undo" : "Update Grid";
          undoBtn.style.backgroundColor =
            lines.length > 0 && history.length > 0 ? "silver" : "#d9f170";
        } else {
          return;
        }
      }

      // Add event listeners
      canvas.addEventListener("pointerdown", startDrawing);
      canvas.addEventListener("pointermove", drawRubberLine);
      canvas.addEventListener("pointerup", () => {
        stopDrawing();
      });
      canvas.addEventListener("pointerout", stopDrawing);

      cancelBtn.addEventListener("click", () => {
        modal.classList.remove("modal_visible");
        textInputEl.value = "";
      });

      confirmBtn.addEventListener("click", () => {
        placeText(startX, startY);
        console.log(lines, history);
      });

      // Add touch events for mobile and tablets
      canvas.addEventListener("touchstart", (event) => {
        event.preventDefault();
        startDrawing(event);
      });
      canvas.addEventListener("touchmove", (event) => {
        event.preventDefault();
        drawRubberLine(event);
      });
      canvas.addEventListener("touchend", (event) => {
        event.preventDefault();
        stopDrawing();
      });
      canvas.addEventListener("touchcancel", stopDrawing);

      // Initialize on DOMContentLoaded
      document.addEventListener("DOMContentLoaded", startup);
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          undo();
        }
      });
    </script>
  </body>
</html>
